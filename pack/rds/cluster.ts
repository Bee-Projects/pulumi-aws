// *** WARNING: this file was generated by the Lumi Terraform Bridge (TFGEN) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as lumi from "@lumi/lumi";
import * as lumirt from "@lumi/lumirt";

export class Cluster extends lumi.NamedResource implements ClusterArgs {
    public readonly applyImmediately: boolean;
    public readonly availabilityZones: string[];
    public readonly backupRetentionPeriod?: number;
    public readonly clusterIdentifier: string;
    public readonly clusterIdentifierPrefix: string;
    public readonly clusterMembers: string[];
    public /*out*/ readonly clusterResourceId: string;
    public readonly databaseName: string;
    public readonly dbClusterParameterGroupName: string;
    public readonly dbSubnetGroupName: string;
    public /*out*/ readonly endpoint: string;
    public /*out*/ readonly engine: string;
    public readonly finalSnapshotIdentifier?: string;
    public readonly iamDatabaseAuthenticationEnabled?: boolean;
    public readonly kmsKeyId: string;
    public readonly masterPassword?: string;
    public readonly masterUsername: string;
    public readonly port: number;
    public readonly preferredBackupWindow: string;
    public readonly preferredMaintenanceWindow: string;
    public /*out*/ readonly readerEndpoint: string;
    public readonly replicationSourceIdentifier?: string;
    public readonly skipFinalSnapshot?: boolean;
    public readonly snapshotIdentifier?: string;
    public readonly storageEncrypted?: boolean;
    public readonly tags?: {[key: string]: any};
    public readonly vpcSecurityGroupIds: string[];

    constructor(name: string, args: ClusterArgs) {
        super(name);
        this.applyImmediately = args.applyImmediately;
        this.availabilityZones = args.availabilityZones;
        this.backupRetentionPeriod = args.backupRetentionPeriod;
        this.clusterIdentifier = args.clusterIdentifier;
        this.clusterIdentifierPrefix = args.clusterIdentifierPrefix;
        this.clusterMembers = args.clusterMembers;
        this.databaseName = args.databaseName;
        this.dbClusterParameterGroupName = args.dbClusterParameterGroupName;
        this.dbSubnetGroupName = args.dbSubnetGroupName;
        this.finalSnapshotIdentifier = args.finalSnapshotIdentifier;
        this.iamDatabaseAuthenticationEnabled = args.iamDatabaseAuthenticationEnabled;
        this.kmsKeyId = args.kmsKeyId;
        this.masterPassword = args.masterPassword;
        this.masterUsername = args.masterUsername;
        this.port = args.port;
        this.preferredBackupWindow = args.preferredBackupWindow;
        this.preferredMaintenanceWindow = args.preferredMaintenanceWindow;
        this.replicationSourceIdentifier = args.replicationSourceIdentifier;
        this.skipFinalSnapshot = args.skipFinalSnapshot;
        this.snapshotIdentifier = args.snapshotIdentifier;
        this.storageEncrypted = args.storageEncrypted;
        this.tags = args.tags;
        this.vpcSecurityGroupIds = args.vpcSecurityGroupIds;
    }
}

export interface ClusterArgs {
    readonly applyImmediately?: boolean;
    readonly availabilityZones?: string[];
    readonly backupRetentionPeriod?: number;
    readonly clusterIdentifier?: string;
    readonly clusterIdentifierPrefix?: string;
    readonly clusterMembers?: string[];
    readonly databaseName?: string;
    readonly dbClusterParameterGroupName?: string;
    readonly dbSubnetGroupName?: string;
    readonly finalSnapshotIdentifier?: string;
    readonly iamDatabaseAuthenticationEnabled?: boolean;
    readonly kmsKeyId?: string;
    readonly masterPassword?: string;
    readonly masterUsername?: string;
    readonly port?: number;
    readonly preferredBackupWindow?: string;
    readonly preferredMaintenanceWindow?: string;
    readonly replicationSourceIdentifier?: string;
    readonly skipFinalSnapshot?: boolean;
    readonly snapshotIdentifier?: string;
    readonly storageEncrypted?: boolean;
    readonly tags?: {[key: string]: any};
    readonly vpcSecurityGroupIds?: string[];
}


// *** WARNING: this file was generated by the Lumi Terraform Bridge (TFGEN) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as lumi from "@lumi/lumi";
import * as lumirt from "@lumi/lumirt";

export class SpotFleetRequest extends lumi.NamedResource implements SpotFleetRequestArgs {
    public readonly allocationStrategy?: string;
    public /*out*/ readonly clientToken: string;
    public readonly excessCapacityTerminationPolicy?: string;
    public readonly iamFleetRole: string;
    public readonly launchSpecification: { ami: string, associatePublicIpAddress?: boolean, availabilityZone: string, ebsBlockDevice: { deleteOnTermination?: boolean, deviceName: string, encrypted: boolean, iops: number, snapshotId: string, volumeSize: number, volumeType: string }[], ebsOptimized?: boolean, ephemeralBlockDevice: { deviceName: string, virtualName: string }[], iamInstanceProfile?: string, instanceType: string, keyName: string, monitoring?: boolean, placementGroup: string, placementTenancy?: string, rootBlockDevice: { deleteOnTermination?: boolean, iops: number, volumeSize: number, volumeType: string }[], spotPrice?: string, subnetId: string, userData?: string, vpcSecurityGroupIds: string[], weightedCapacity?: string }[];
    public readonly replaceUnhealthyInstances?: boolean;
    public readonly spotPrice: string;
    public /*out*/ readonly spotRequestState: string;
    public readonly targetCapacity: number;
    public readonly terminateInstancesWithExpiration?: boolean;
    public readonly validFrom?: string;
    public readonly validUntil?: string;

    constructor(name: string, args: SpotFleetRequestArgs) {
        super(name);
        this.allocationStrategy = args.allocationStrategy;
        this.excessCapacityTerminationPolicy = args.excessCapacityTerminationPolicy;
        if (lumirt.defaultIfComputed(args.iamFleetRole, "") === undefined) {
            throw new Error("Property argument 'iamFleetRole' is required, but was missing");
        }
        this.iamFleetRole = args.iamFleetRole;
        if (lumirt.defaultIfComputed(args.launchSpecification, "") === undefined) {
            throw new Error("Property argument 'launchSpecification' is required, but was missing");
        }
        this.launchSpecification = args.launchSpecification;
        this.replaceUnhealthyInstances = args.replaceUnhealthyInstances;
        if (lumirt.defaultIfComputed(args.spotPrice, "") === undefined) {
            throw new Error("Property argument 'spotPrice' is required, but was missing");
        }
        this.spotPrice = args.spotPrice;
        if (lumirt.defaultIfComputed(args.targetCapacity, "") === undefined) {
            throw new Error("Property argument 'targetCapacity' is required, but was missing");
        }
        this.targetCapacity = args.targetCapacity;
        this.terminateInstancesWithExpiration = args.terminateInstancesWithExpiration;
        this.validFrom = args.validFrom;
        this.validUntil = args.validUntil;
    }
}

export interface SpotFleetRequestArgs {
    readonly allocationStrategy?: string;
    readonly excessCapacityTerminationPolicy?: string;
    readonly iamFleetRole: string;
    readonly launchSpecification: { ami: string, associatePublicIpAddress?: boolean, availabilityZone: string, ebsBlockDevice: { deleteOnTermination?: boolean, deviceName: string, encrypted: boolean, iops: number, snapshotId: string, volumeSize: number, volumeType: string }[], ebsOptimized?: boolean, ephemeralBlockDevice: { deviceName: string, virtualName: string }[], iamInstanceProfile?: string, instanceType: string, keyName: string, monitoring?: boolean, placementGroup: string, placementTenancy?: string, rootBlockDevice: { deleteOnTermination?: boolean, iops: number, volumeSize: number, volumeType: string }[], spotPrice?: string, subnetId: string, userData?: string, vpcSecurityGroupIds: string[], weightedCapacity?: string }[];
    readonly replaceUnhealthyInstances?: boolean;
    readonly spotPrice: string;
    readonly targetCapacity: number;
    readonly terminateInstancesWithExpiration?: boolean;
    readonly validFrom?: string;
    readonly validUntil?: string;
}


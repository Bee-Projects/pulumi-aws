// *** WARNING: this file was generated by the Lumi Terraform Bridge (TFGEN) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as lumi from "@lumi/lumi";
import * as lumirt from "@lumi/lumirt";

export class Cluster extends lumi.NamedResource implements ClusterArgs {
    public readonly allowVersionUpgrade?: boolean;
    public readonly automatedSnapshotRetentionPeriod?: number;
    public readonly availabilityZone: string;
    public readonly bucketName: string;
    public readonly clusterIdentifier: string;
    public readonly clusterParameterGroupName: string;
    public readonly clusterPublicKey: string;
    public readonly clusterRevisionNumber: string;
    public readonly clusterSecurityGroups: string[];
    public readonly clusterSubnetGroupName: string;
    public readonly clusterType: string;
    public readonly clusterVersion?: string;
    public readonly databaseName: string;
    public readonly elasticIp?: string;
    public readonly enableLogging?: boolean;
    public readonly encrypted: boolean;
    public readonly endpoint: string;
    public readonly enhancedVpcRouting: boolean;
    public readonly finalSnapshotIdentifier?: string;
    public readonly iamRoles: string[];
    public readonly kmsKeyId: string;
    public readonly masterPassword?: string;
    public readonly masterUsername?: string;
    public readonly nodeType: string;
    public readonly numberOfNodes?: number;
    public readonly ownerAccount?: string;
    public readonly port?: number;
    public readonly preferredMaintenanceWindow: string;
    public readonly publiclyAccessible?: boolean;
    public readonly s3KeyPrefix: string;
    public readonly skipFinalSnapshot?: boolean;
    public readonly snapshotClusterIdentifier?: string;
    public readonly snapshotIdentifier?: string;
    public readonly tags?: {[key: string]: any};
    public readonly vpcSecurityGroupIds: string[];

    public static get(id: lumi.ID): Cluster {
        return <any>undefined; // functionality provided by the runtime
    }

    public static query(q: any): Cluster[] {
        return <any>undefined; // functionality provided by the runtime
    }

    constructor(name: string, args: ClusterArgs) {
        super(name);
        this.allowVersionUpgrade = <any>args.allowVersionUpgrade;
        this.automatedSnapshotRetentionPeriod = <any>args.automatedSnapshotRetentionPeriod;
        this.availabilityZone = <any>args.availabilityZone;
        this.bucketName = <any>args.bucketName;
        if (lumirt.defaultIfComputed(args.clusterIdentifier, "") === undefined) {
            throw new Error("Property argument 'clusterIdentifier' is required, but was missing");
        }
        this.clusterIdentifier = <any>args.clusterIdentifier;
        this.clusterParameterGroupName = <any>args.clusterParameterGroupName;
        this.clusterPublicKey = <any>args.clusterPublicKey;
        this.clusterRevisionNumber = <any>args.clusterRevisionNumber;
        this.clusterSecurityGroups = <any>args.clusterSecurityGroups;
        this.clusterSubnetGroupName = <any>args.clusterSubnetGroupName;
        this.clusterType = <any>args.clusterType;
        this.clusterVersion = <any>args.clusterVersion;
        this.databaseName = <any>args.databaseName;
        this.elasticIp = <any>args.elasticIp;
        this.enableLogging = <any>args.enableLogging;
        this.encrypted = <any>args.encrypted;
        this.endpoint = <any>args.endpoint;
        this.enhancedVpcRouting = <any>args.enhancedVpcRouting;
        this.finalSnapshotIdentifier = <any>args.finalSnapshotIdentifier;
        this.iamRoles = <any>args.iamRoles;
        this.kmsKeyId = <any>args.kmsKeyId;
        this.masterPassword = <any>args.masterPassword;
        this.masterUsername = <any>args.masterUsername;
        if (lumirt.defaultIfComputed(args.nodeType, "") === undefined) {
            throw new Error("Property argument 'nodeType' is required, but was missing");
        }
        this.nodeType = <any>args.nodeType;
        this.numberOfNodes = <any>args.numberOfNodes;
        this.ownerAccount = <any>args.ownerAccount;
        this.port = <any>args.port;
        this.preferredMaintenanceWindow = <any>args.preferredMaintenanceWindow;
        this.publiclyAccessible = <any>args.publiclyAccessible;
        this.s3KeyPrefix = <any>args.s3KeyPrefix;
        this.skipFinalSnapshot = <any>args.skipFinalSnapshot;
        this.snapshotClusterIdentifier = <any>args.snapshotClusterIdentifier;
        this.snapshotIdentifier = <any>args.snapshotIdentifier;
        this.tags = <any>args.tags;
        this.vpcSecurityGroupIds = <any>args.vpcSecurityGroupIds;
    }
}

export interface ClusterArgs {
    readonly allowVersionUpgrade?: boolean;
    readonly automatedSnapshotRetentionPeriod?: number;
    readonly availabilityZone?: string;
    readonly bucketName?: string;
    readonly clusterIdentifier: string;
    readonly clusterParameterGroupName?: string;
    readonly clusterPublicKey?: string;
    readonly clusterRevisionNumber?: string;
    readonly clusterSecurityGroups?: string[];
    readonly clusterSubnetGroupName?: string;
    readonly clusterType?: string;
    readonly clusterVersion?: string;
    readonly databaseName?: string;
    readonly elasticIp?: string;
    readonly enableLogging?: boolean;
    readonly encrypted?: boolean;
    readonly endpoint?: string;
    readonly enhancedVpcRouting?: boolean;
    readonly finalSnapshotIdentifier?: string;
    readonly iamRoles?: string[];
    readonly kmsKeyId?: string;
    readonly masterPassword?: string;
    readonly masterUsername?: string;
    readonly nodeType: string;
    readonly numberOfNodes?: number;
    readonly ownerAccount?: string;
    readonly port?: number;
    readonly preferredMaintenanceWindow?: string;
    readonly publiclyAccessible?: boolean;
    readonly s3KeyPrefix?: string;
    readonly skipFinalSnapshot?: boolean;
    readonly snapshotClusterIdentifier?: string;
    readonly snapshotIdentifier?: string;
    readonly tags?: {[key: string]: any};
    readonly vpcSecurityGroupIds?: string[];
}


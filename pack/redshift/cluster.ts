// *** WARNING: this file was generated by the Lumi Terraform Bridge (TFGEN) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as lumi from "@lumi/lumi";
import * as lumirt from "@lumi/lumirt";

export class Cluster extends lumi.NamedResource implements ClusterArgs {
    public readonly allowVersionUpgrade?: boolean;
    public readonly automatedSnapshotRetentionPeriod?: number;
    public readonly availabilityZone: string;
    public readonly bucketName: string;
    public readonly clusterIdentifier: string;
    public readonly clusterParameterGroupName: string;
    public readonly clusterPublicKey: string;
    public readonly clusterRevisionNumber: string;
    public readonly clusterSecurityGroups: string[];
    public readonly clusterSubnetGroupName: string;
    public readonly clusterType: string;
    public readonly clusterVersion?: string;
    public readonly databaseName: string;
    public readonly elasticIp?: string;
    public readonly enableLogging?: boolean;
    public readonly encrypted: boolean;
    public readonly endpoint: string;
    public readonly enhancedVpcRouting: boolean;
    public readonly finalSnapshotIdentifier?: string;
    public readonly iamRoles: string[];
    public readonly kmsKeyId: string;
    public readonly masterPassword?: string;
    public readonly masterUsername?: string;
    public readonly nodeType: string;
    public readonly numberOfNodes?: number;
    public readonly ownerAccount?: string;
    public readonly port?: number;
    public readonly preferredMaintenanceWindow: string;
    public readonly publiclyAccessible?: boolean;
    public readonly s3KeyPrefix: string;
    public readonly skipFinalSnapshot?: boolean;
    public readonly snapshotClusterIdentifier?: string;
    public readonly snapshotIdentifier?: string;
    public readonly tags?: {[key: string]: any};
    public readonly vpcSecurityGroupIds: string[];

    constructor(name: string, args: ClusterArgs) {
        super(name);
        this.allowVersionUpgrade = args.allowVersionUpgrade;
        this.automatedSnapshotRetentionPeriod = args.automatedSnapshotRetentionPeriod;
        this.availabilityZone = args.availabilityZone;
        this.bucketName = args.bucketName;
        if (lumirt.defaultIfComputed(args.clusterIdentifier, "") === undefined) {
            throw new Error("Property argument 'clusterIdentifier' is required, but was missing");
        }
        this.clusterIdentifier = args.clusterIdentifier;
        this.clusterParameterGroupName = args.clusterParameterGroupName;
        this.clusterPublicKey = args.clusterPublicKey;
        this.clusterRevisionNumber = args.clusterRevisionNumber;
        this.clusterSecurityGroups = args.clusterSecurityGroups;
        this.clusterSubnetGroupName = args.clusterSubnetGroupName;
        this.clusterType = args.clusterType;
        this.clusterVersion = args.clusterVersion;
        this.databaseName = args.databaseName;
        this.elasticIp = args.elasticIp;
        this.enableLogging = args.enableLogging;
        this.encrypted = args.encrypted;
        this.endpoint = args.endpoint;
        this.enhancedVpcRouting = args.enhancedVpcRouting;
        this.finalSnapshotIdentifier = args.finalSnapshotIdentifier;
        this.iamRoles = args.iamRoles;
        this.kmsKeyId = args.kmsKeyId;
        this.masterPassword = args.masterPassword;
        this.masterUsername = args.masterUsername;
        if (lumirt.defaultIfComputed(args.nodeType, "") === undefined) {
            throw new Error("Property argument 'nodeType' is required, but was missing");
        }
        this.nodeType = args.nodeType;
        this.numberOfNodes = args.numberOfNodes;
        this.ownerAccount = args.ownerAccount;
        this.port = args.port;
        this.preferredMaintenanceWindow = args.preferredMaintenanceWindow;
        this.publiclyAccessible = args.publiclyAccessible;
        this.s3KeyPrefix = args.s3KeyPrefix;
        this.skipFinalSnapshot = args.skipFinalSnapshot;
        this.snapshotClusterIdentifier = args.snapshotClusterIdentifier;
        this.snapshotIdentifier = args.snapshotIdentifier;
        this.tags = args.tags;
        this.vpcSecurityGroupIds = args.vpcSecurityGroupIds;
    }
}

export interface ClusterArgs {
    readonly allowVersionUpgrade?: boolean;
    readonly automatedSnapshotRetentionPeriod?: number;
    readonly availabilityZone?: string;
    readonly bucketName?: string;
    readonly clusterIdentifier: string;
    readonly clusterParameterGroupName?: string;
    readonly clusterPublicKey?: string;
    readonly clusterRevisionNumber?: string;
    readonly clusterSecurityGroups?: string[];
    readonly clusterSubnetGroupName?: string;
    readonly clusterType?: string;
    readonly clusterVersion?: string;
    readonly databaseName?: string;
    readonly elasticIp?: string;
    readonly enableLogging?: boolean;
    readonly encrypted?: boolean;
    readonly endpoint?: string;
    readonly enhancedVpcRouting?: boolean;
    readonly finalSnapshotIdentifier?: string;
    readonly iamRoles?: string[];
    readonly kmsKeyId?: string;
    readonly masterPassword?: string;
    readonly masterUsername?: string;
    readonly nodeType: string;
    readonly numberOfNodes?: number;
    readonly ownerAccount?: string;
    readonly port?: number;
    readonly preferredMaintenanceWindow?: string;
    readonly publiclyAccessible?: boolean;
    readonly s3KeyPrefix?: string;
    readonly skipFinalSnapshot?: boolean;
    readonly snapshotClusterIdentifier?: string;
    readonly snapshotIdentifier?: string;
    readonly tags?: {[key: string]: any};
    readonly vpcSecurityGroupIds?: string[];
}


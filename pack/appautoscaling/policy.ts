// *** WARNING: this file was generated by the Lumi Terraform Bridge (TFGEN) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as lumi from "@lumi/lumi";
import * as lumirt from "@lumi/lumirt";

export class Policy extends lumi.NamedResource implements PolicyArgs {
    public readonly adjustmentType: string;
    public readonly alarms?: string[];
    public /*out*/ readonly arn: string;
    public readonly cooldown: number;
    public readonly metricAggregationType: string;
    public readonly minAdjustmentMagnitude?: number;
    public readonly policyName?: string;
    public readonly policyType?: string;
    public readonly resourceId: string;
    public readonly scalableDimension: string;
    public readonly serviceNamespace: string;
    public readonly stepAdjustment?: { metricIntervalLowerBound?: string, metricIntervalUpperBound?: string, scalingAdjustment: number }[];

    constructor(name: string, args: PolicyArgs) {
        super(name);
        if (lumirt.defaultIfComputed(args.adjustmentType, "") === undefined) {
            throw new Error("Property argument 'adjustmentType' is required, but was missing");
        }
        this.adjustmentType = args.adjustmentType;
        this.alarms = args.alarms;
        if (lumirt.defaultIfComputed(args.cooldown, "") === undefined) {
            throw new Error("Property argument 'cooldown' is required, but was missing");
        }
        this.cooldown = args.cooldown;
        if (lumirt.defaultIfComputed(args.metricAggregationType, "") === undefined) {
            throw new Error("Property argument 'metricAggregationType' is required, but was missing");
        }
        this.metricAggregationType = args.metricAggregationType;
        this.minAdjustmentMagnitude = args.minAdjustmentMagnitude;
        this.policyName = args.policyName;
        this.policyType = args.policyType;
        if (lumirt.defaultIfComputed(args.resourceId, "") === undefined) {
            throw new Error("Property argument 'resourceId' is required, but was missing");
        }
        this.resourceId = args.resourceId;
        if (lumirt.defaultIfComputed(args.scalableDimension, "") === undefined) {
            throw new Error("Property argument 'scalableDimension' is required, but was missing");
        }
        this.scalableDimension = args.scalableDimension;
        if (lumirt.defaultIfComputed(args.serviceNamespace, "") === undefined) {
            throw new Error("Property argument 'serviceNamespace' is required, but was missing");
        }
        this.serviceNamespace = args.serviceNamespace;
        this.stepAdjustment = args.stepAdjustment;
    }
}

export interface PolicyArgs {
    readonly adjustmentType: string;
    readonly alarms?: string[];
    readonly cooldown: number;
    readonly metricAggregationType: string;
    readonly minAdjustmentMagnitude?: number;
    readonly policyName?: string;
    readonly policyType?: string;
    readonly resourceId: string;
    readonly scalableDimension: string;
    readonly serviceNamespace: string;
    readonly stepAdjustment?: { metricIntervalLowerBound?: string, metricIntervalUpperBound?: string, scalingAdjustment: number }[];
}


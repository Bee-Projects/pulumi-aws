// *** WARNING: this file was generated by the Lumi Terraform Bridge (TFGEN) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as lumi from "@lumi/lumi";
import * as lumirt from "@lumi/lumirt";

export class Cluster extends lumi.NamedResource implements ClusterArgs {
    public readonly applications?: string[];
    public readonly autoscalingRole?: string;
    public readonly bootstrapAction?: { args?: string[], name: string, path: string }[];
    public /*out*/ readonly clusterState: string;
    public readonly configurations?: string;
    public readonly coreInstanceCount?: number;
    public readonly coreInstanceType: string;
    public readonly ec2Attributes?: { additionalMasterSecurityGroups?: string, additionalSlaveSecurityGroups?: string, emrManagedMasterSecurityGroup?: string, emrManagedSlaveSecurityGroup?: string, instanceProfile: string, keyName?: string, serviceAccessSecurityGroup?: string, subnetId?: string }[];
    public readonly keepJobFlowAliveWhenNoSteps: boolean;
    public readonly logUri?: string;
    public readonly masterInstanceType: string;
    public /*out*/ readonly masterPublicDns: string;
    public readonly name: string;
    public readonly releaseLabel: string;
    public readonly securityConfiguration?: string;
    public readonly serviceRole: string;
    public readonly tags?: {[key: string]: any};
    public readonly terminationProtection: boolean;
    public readonly visibleToAllUsers?: boolean;

    public static get(id: lumi.ID): Cluster {
        return <any>undefined; // functionality provided by the runtime
    }

    public static query(q: any): Cluster[] {
        return <any>undefined; // functionality provided by the runtime
    }

    constructor(urnName: string, args: ClusterArgs) {
        super(urnName);
        this.applications = <any>args.applications;
        this.autoscalingRole = <any>args.autoscalingRole;
        this.bootstrapAction = <any>args.bootstrapAction;
        this.configurations = <any>args.configurations;
        this.coreInstanceCount = <any>args.coreInstanceCount;
        this.coreInstanceType = <any>args.coreInstanceType;
        this.ec2Attributes = <any>args.ec2Attributes;
        this.keepJobFlowAliveWhenNoSteps = <any>args.keepJobFlowAliveWhenNoSteps;
        this.logUri = <any>args.logUri;
        if (lumirt.defaultIfComputed(args.masterInstanceType, "") === undefined) {
            throw new Error("Property argument 'masterInstanceType' is required, but was missing");
        }
        this.masterInstanceType = <any>args.masterInstanceType;
        this.name = <any>args.name;
        if (lumirt.defaultIfComputed(args.releaseLabel, "") === undefined) {
            throw new Error("Property argument 'releaseLabel' is required, but was missing");
        }
        this.releaseLabel = <any>args.releaseLabel;
        this.securityConfiguration = <any>args.securityConfiguration;
        if (lumirt.defaultIfComputed(args.serviceRole, "") === undefined) {
            throw new Error("Property argument 'serviceRole' is required, but was missing");
        }
        this.serviceRole = <any>args.serviceRole;
        this.tags = <any>args.tags;
        this.terminationProtection = <any>args.terminationProtection;
        this.visibleToAllUsers = <any>args.visibleToAllUsers;
    }
}

export interface ClusterArgs {
    readonly applications?: string[];
    readonly autoscalingRole?: string;
    readonly bootstrapAction?: { args?: string[], name: string, path: string }[];
    readonly configurations?: string;
    readonly coreInstanceCount?: number;
    readonly coreInstanceType?: string;
    readonly ec2Attributes?: { additionalMasterSecurityGroups?: string, additionalSlaveSecurityGroups?: string, emrManagedMasterSecurityGroup?: string, emrManagedSlaveSecurityGroup?: string, instanceProfile: string, keyName?: string, serviceAccessSecurityGroup?: string, subnetId?: string }[];
    readonly keepJobFlowAliveWhenNoSteps?: boolean;
    readonly logUri?: string;
    readonly masterInstanceType: string;
    readonly name?: string;
    readonly releaseLabel: string;
    readonly securityConfiguration?: string;
    readonly serviceRole: string;
    readonly tags?: {[key: string]: any};
    readonly terminationProtection?: boolean;
    readonly visibleToAllUsers?: boolean;
}


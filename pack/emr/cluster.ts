// *** WARNING: this file was generated by the Lumi Terraform Bridge (TFGEN) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as lumi from "@lumi/lumi";
import * as lumirt from "@lumi/lumirt";

export class Cluster extends lumi.NamedResource implements ClusterArgs {
    public readonly applications?: string[];
    public readonly autoscalingRole?: string;
    public readonly bootstrapAction?: { args?: string[], name: string, path: string }[];
    public /*out*/ readonly clusterState: string;
    public readonly configurations?: string;
    public readonly coreInstanceCount?: number;
    public readonly coreInstanceType: string;
    public readonly ec2Attributes?: { additionalMasterSecurityGroups?: string, additionalSlaveSecurityGroups?: string, emrManagedMasterSecurityGroup?: string, emrManagedSlaveSecurityGroup?: string, instanceProfile: string, keyName?: string, serviceAccessSecurityGroup?: string, subnetId?: string }[];
    public readonly keepJobFlowAliveWhenNoSteps: boolean;
    public readonly logUri?: string;
    public readonly masterInstanceType: string;
    public /*out*/ readonly masterPublicDns: string;
    public readonly clusterName?: string;
    public readonly releaseLabel: string;
    public readonly securityConfiguration?: string;
    public readonly serviceRole: string;
    public readonly tags?: {[key: string]: any};
    public readonly terminationProtection: boolean;
    public readonly visibleToAllUsers?: boolean;

    constructor(name: string, args: ClusterArgs) {
        super(name);
        this.applications = args.applications;
        this.autoscalingRole = args.autoscalingRole;
        this.bootstrapAction = args.bootstrapAction;
        this.configurations = args.configurations;
        this.coreInstanceCount = args.coreInstanceCount;
        this.coreInstanceType = args.coreInstanceType;
        this.ec2Attributes = args.ec2Attributes;
        this.keepJobFlowAliveWhenNoSteps = args.keepJobFlowAliveWhenNoSteps;
        this.logUri = args.logUri;
        if (lumirt.defaultIfComputed(args.masterInstanceType, "") === undefined) {
            throw new Error("Property argument 'masterInstanceType' is required, but was missing");
        }
        this.masterInstanceType = args.masterInstanceType;
        this.clusterName = args.clusterName;
        if (lumirt.defaultIfComputed(args.releaseLabel, "") === undefined) {
            throw new Error("Property argument 'releaseLabel' is required, but was missing");
        }
        this.releaseLabel = args.releaseLabel;
        this.securityConfiguration = args.securityConfiguration;
        if (lumirt.defaultIfComputed(args.serviceRole, "") === undefined) {
            throw new Error("Property argument 'serviceRole' is required, but was missing");
        }
        this.serviceRole = args.serviceRole;
        this.tags = args.tags;
        this.terminationProtection = args.terminationProtection;
        this.visibleToAllUsers = args.visibleToAllUsers;
    }
}

export interface ClusterArgs {
    readonly applications?: string[];
    readonly autoscalingRole?: string;
    readonly bootstrapAction?: { args?: string[], name: string, path: string }[];
    readonly configurations?: string;
    readonly coreInstanceCount?: number;
    readonly coreInstanceType?: string;
    readonly ec2Attributes?: { additionalMasterSecurityGroups?: string, additionalSlaveSecurityGroups?: string, emrManagedMasterSecurityGroup?: string, emrManagedSlaveSecurityGroup?: string, instanceProfile: string, keyName?: string, serviceAccessSecurityGroup?: string, subnetId?: string }[];
    readonly keepJobFlowAliveWhenNoSteps?: boolean;
    readonly logUri?: string;
    readonly masterInstanceType: string;
    readonly clusterName?: string;
    readonly releaseLabel: string;
    readonly securityConfiguration?: string;
    readonly serviceRole: string;
    readonly tags?: {[key: string]: any};
    readonly terminationProtection?: boolean;
    readonly visibleToAllUsers?: boolean;
}

